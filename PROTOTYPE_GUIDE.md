# Prototype Guide - Building a Functional Prototype with Limited Data

This guide shows you how to create a working prototype of Ballot Builder without building the full app.

## Why Prototype First?

âœ… **Learn by doing** - Build something tangible quickly
âœ… **Test the concept** - See if the idea actually works
âœ… **Get feedback early** - Before investing months of development
âœ… **Lower complexity** - No backend, databases, or complex AI needed
âœ… **Perfect for learning** - Focus on core functionality

---

## Prototype Options (Choose One)

### Option 1: React Web App (Recommended) â­

**Time:** 2-3 weeks
**Difficulty:** Beginner-friendly
**What you'll learn:** React, TypeScript, component design

**Tech Stack:**
- React (Create React App or Vite)
- TypeScript
- CSS/Tailwind for styling
- No backend needed

**Features:**
1. Swipe interface with 30 mock statements
2. Simple scoring system
3. Mock ballot with 10 items
4. Confidence gauge display
5. Basic explanations

---

### Option 2: Figma Prototype (Easiest)

**Time:** 1 week
**Difficulty:** No coding required
**What you'll learn:** UX design, user flows

**Tool:** Figma (free)

**What to create:**
- All screen designs
- Clickable prototype
- Animated transitions
- Demonstration of flow

---

### Option 3: Mobile Prototype (React Native)

**Time:** 3-4 weeks
**Difficulty:** Intermediate
**What you'll learn:** React Native, mobile development

**Same as Option 1 but for mobile**

---

## Detailed Plan: React Web Prototype

### Project Structure

```
ballot-builder-prototype/
â”œâ”€â”€ public/
â”‚   â””â”€â”€ index.html
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ SwipeCard.tsx
â”‚   â”‚   â”œâ”€â”€ ConfidenceGauge.tsx
â”‚   â”‚   â”œâ”€â”€ BallotItem.tsx
â”‚   â”‚   â””â”€â”€ ProgressBar.tsx
â”‚   â”‚
â”‚   â”œâ”€â”€ screens/
â”‚   â”‚   â”œâ”€â”€ WelcomeScreen.tsx
â”‚   â”‚   â”œâ”€â”€ IntakeScreen.tsx
â”‚   â”‚   â”œâ”€â”€ SwipeScreen.tsx
â”‚   â”‚   â”œâ”€â”€ ResultsScreen.tsx
â”‚   â”‚   â””â”€â”€ BallotScreen.tsx
â”‚   â”‚
â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â”œâ”€â”€ statements.json
â”‚   â”‚   â”œâ”€â”€ ballot.json
â”‚   â”‚   â””â”€â”€ explanations.json
â”‚   â”‚
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ scoring.ts
â”‚   â”‚   â””â”€â”€ matching.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ App.tsx
â”‚   â””â”€â”€ index.tsx
â”‚
â”œâ”€â”€ package.json
â””â”€â”€ README.md
```

---

## Step-by-Step Implementation

### Step 1: Create Mock Data Files

#### `src/data/statements.json`

```json
{
  "statements": [
    {
      "id": "1",
      "text": "Healthcare should be more affordable and accessible for everyone",
      "category": "healthcare",
      "vector": [0.8, 0.2, 0.1, 0.3, 0.5]
    },
    {
      "id": "2",
      "text": "We should invest significantly more in renewable energy",
      "category": "environment",
      "vector": [0.2, 0.1, 0.9, 0.3, 0.4]
    },
    {
      "id": "3",
      "text": "Education funding should be increased at all levels",
      "category": "education",
      "vector": [0.3, 0.9, 0.2, 0.1, 0.6]
    },
    {
      "id": "4",
      "text": "Income tax rates should be more progressive",
      "category": "economy",
      "vector": [0.1, 0.3, 0.2, 0.8, 0.3]
    },
    {
      "id": "5",
      "text": "Public transportation should be expanded and subsidized",
      "category": "infrastructure",
      "vector": [0.4, 0.5, 0.6, 0.4, 0.9]
    }
  ]
}
```

**Note:** In the real app, these vectors would be generated by AI. For the prototype, we just make them up!

#### `src/data/ballot.json`

```json
{
  "ballot": [
    {
      "id": "1",
      "type": "candidate",
      "position": "Governor",
      "title": "Governor",
      "candidates": [
        {
          "name": "Jane Smith",
          "party": "Democratic",
          "vector": [0.7, 0.6, 0.8, 0.7, 0.6],
          "positions": [
            "Universal healthcare expansion",
            "Clean energy investment",
            "Education funding increase"
          ]
        },
        {
          "name": "John Doe",
          "party": "Republican",
          "vector": [0.3, 0.4, 0.2, 0.3, 0.4],
          "positions": [
            "Healthcare market competition",
            "Energy independence",
            "School choice"
          ]
        }
      ]
    },
    {
      "id": "2",
      "type": "measure",
      "title": "Proposition 42: Education Funding",
      "shortTitle": "Prop 42",
      "description": "Increases state education funding by implementing a 0.5% sales tax increase",
      "vector": [0.3, 0.9, 0.2, 0.6, 0.5],
      "outcomes": {
        "yes": "Public schools receive additional $500M annually for teacher salaries and facilities",
        "no": "School funding remains at current levels, no tax increase"
      },
      "explanation": "This measure would provide significant additional funding to public schools by adding a small sales tax. If you value education funding and don't mind a slight tax increase, this aligns with those values."
    },
    {
      "id": "3",
      "type": "measure",
      "title": "Measure A: Affordable Housing",
      "shortTitle": "Measure A",
      "description": "Allows construction of affordable housing units in single-family residential zones",
      "vector": [0.6, 0.4, 0.3, 0.7, 0.8],
      "outcomes": {
        "yes": "Up to 1000 new affordable units can be built, changing zoning laws",
        "no": "Current zoning restrictions remain, no new construction allowed"
      },
      "explanation": "This measure addresses housing affordability by allowing more construction. It's a trade-off between increasing housing supply and maintaining neighborhood character."
    }
  ]
}
```

---

### Step 2: Build Core Components

#### `src/utils/scoring.ts`

```typescript
/**
 * Simple scoring system for the prototype
 * In the real app, this would use proper embeddings
 */

export interface UserPreferences {
  healthcare: number;
  education: number;
  environment: number;
  economy: number;
  infrastructure: number;
}

export const calculateUserVector = (
  responses: Array<{ statementId: string; response: 'agree' | 'disagree'; vector: number[] }>
): number[] => {
  // Start with neutral vector
  const userVector = [0, 0, 0, 0, 0];

  if (responses.length === 0) return userVector;

  // Simple averaging approach
  responses.forEach(({ response, vector }) => {
    const multiplier = response === 'agree' ? 1 : -1;
    vector.forEach((val, idx) => {
      userVector[idx] += val * multiplier;
    });
  });

  // Average
  userVector.forEach((_, idx) => {
    userVector[idx] /= responses.length;
  });

  return userVector;
};

export const cosineSimilarity = (vecA: number[], vecB: number[]): number => {
  let dotProduct = 0;
  let magA = 0;
  let magB = 0;

  for (let i = 0; i < vecA.length; i++) {
    dotProduct += vecA[i] * vecB[i];
    magA += vecA[i] * vecA[i];
    magB += vecB[i] * vecB[i];
  }

  magA = Math.sqrt(magA);
  magB = Math.sqrt(magB);

  if (magA === 0 || magB === 0) return 0;

  return dotProduct / (magA * magB);
};

export const calculateConfidence = (similarity: number): number => {
  // Convert from [-1, 1] to [0, 100]
  return Math.round(((similarity + 1) / 2) * 100);
};
```

#### `src/components/SwipeCard.tsx`

```typescript
import React, { useState } from 'react';
import './SwipeCard.css';

interface SwipeCardProps {
  statement: string;
  category: string;
  onSwipe: (direction: 'agree' | 'disagree') => void;
}

export const SwipeCard: React.FC<SwipeCardProps> = ({
  statement,
  category,
  onSwipe,
}) => {
  const [position, setPosition] = useState(0);
  const [isDragging, setIsDragging] = useState(false);

  const handleMouseDown = () => setIsDragging(true);
  const handleMouseUp = () => {
    setIsDragging(false);

    if (position > 100) {
      onSwipe('agree');
    } else if (position < -100) {
      onSwipe('disagree');
    }

    setPosition(0);
  };

  const handleMouseMove = (e: React.MouseEvent) => {
    if (isDragging) {
      setPosition(position + e.movementX);
    }
  };

  const opacity = 1 - Math.abs(position) / 200;
  const rotation = position / 20;

  return (
    <div className="swipe-container">
      <div
        className="swipe-card"
        style={{
          transform: `translateX(${position}px) rotate(${rotation}deg)`,
          opacity,
        }}
        onMouseDown={handleMouseDown}
        onMouseUp={handleMouseUp}
        onMouseMove={handleMouseMove}
      >
        <div className="category-badge">{category}</div>
        <p className="statement-text">{statement}</p>

        <div className="swipe-indicators">
          <div className="indicator disagree" style={{ opacity: position < -50 ? 1 : 0.3 }}>
            ğŸ‘ Disagree
          </div>
          <div className="indicator agree" style={{ opacity: position > 50 ? 1 : 0.3 }}>
            ğŸ‘ Agree
          </div>
        </div>
      </div>

      <div className="button-controls">
        <button className="btn-disagree" onClick={() => onSwipe('disagree')}>
          âœ• Disagree
        </button>
        <button className="btn-agree" onClick={() => onSwipe('agree')}>
          âœ“ Agree
        </button>
      </div>
    </div>
  );
};
```

#### `src/components/ConfidenceGauge.tsx`

```typescript
import React from 'react';
import './ConfidenceGauge.css';

interface ConfidenceGaugeProps {
  confidence: number;
  label?: string;
}

export const ConfidenceGauge: React.FC<ConfidenceGaugeProps> = ({
  confidence,
  label = 'Match',
}) => {
  const getColor = () => {
    if (confidence < 50) return '#FF3B30';
    if (confidence < 75) return '#FF9500';
    return '#34C759';
  };

  const getLabel = () => {
    if (confidence < 50) return 'Low confidence';
    if (confidence < 75) return 'Moderate confidence';
    return 'High confidence';
  };

  return (
    <div className="confidence-gauge">
      <div className="percentage" style={{ color: getColor() }}>
        {confidence}%
      </div>
      <div className="label">{label}</div>
      <div className="progress-bar">
        <div
          className="progress-fill"
          style={{
            width: `${confidence}%`,
            backgroundColor: getColor(),
          }}
        />
      </div>
      <div className="confidence-label">{getLabel()}</div>
    </div>
  );
};
```

---

### Step 3: Build Main Screens

#### `src/screens/SwipeScreen.tsx`

```typescript
import React, { useState } from 'react';
import { SwipeCard } from '../components/SwipeCard';
import statementsData from '../data/statements.json';

interface Response {
  statementId: string;
  response: 'agree' | 'disagree';
  vector: number[];
}

export const SwipeScreen: React.FC = () => {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [responses, setResponses] = useState<Response[]>([]);

  const currentStatement = statementsData.statements[currentIndex];

  const handleSwipe = (direction: 'agree' | 'disagree') => {
    // Save response
    setResponses([
      ...responses,
      {
        statementId: currentStatement.id,
        response: direction,
        vector: currentStatement.vector,
      },
    ]);

    // Move to next card
    if (currentIndex < statementsData.statements.length - 1) {
      setCurrentIndex(currentIndex + 1);
    } else {
      // Done! Navigate to results
      // In a real app, use React Router
      console.log('All done!', responses);
    }
  };

  const progress = ((currentIndex + 1) / statementsData.statements.length) * 100;

  return (
    <div className="swipe-screen">
      <header>
        <h1>Build Your Civic Blueprint</h1>
        <div className="progress-bar-container">
          <div className="progress-bar-fill" style={{ width: `${progress}%` }} />
        </div>
        <p>{currentIndex + 1} of {statementsData.statements.length}</p>
      </header>

      <SwipeCard
        statement={currentStatement.text}
        category={currentStatement.category}
        onSwipe={handleSwipe}
      />
    </div>
  );
};
```

#### `src/screens/BallotScreen.tsx`

```typescript
import React, { useState, useEffect } from 'react';
import { ConfidenceGauge } from '../components/ConfidenceGauge';
import ballotData from '../data/ballot.json';
import { calculateUserVector, cosineSimilarity, calculateConfidence } from '../utils/scoring';

interface BallotScreenProps {
  userResponses: Array<{ statementId: string; response: 'agree' | 'disagree'; vector: number[] }>;
}

export const BallotScreen: React.FC<BallotScreenProps> = ({ userResponses }) => {
  const [recommendations, setRecommendations] = useState<any[]>([]);

  useEffect(() => {
    // Calculate user vector from responses
    const userVector = calculateUserVector(userResponses);

    // Calculate confidence for each ballot item
    const recs = ballotData.ballot.map((item) => {
      if (item.type === 'candidate') {
        // For candidates, find best match
        const candidateMatches = item.candidates.map((candidate) => {
          const similarity = cosineSimilarity(userVector, candidate.vector);
          const confidence = calculateConfidence(similarity);
          return { ...candidate, confidence };
        });

        candidateMatches.sort((a, b) => b.confidence - a.confidence);

        return {
          ...item,
          recommendation: candidateMatches[0],
          allCandidates: candidateMatches,
        };
      } else {
        // For measures, calculate support
        const similarity = cosineSimilarity(userVector, item.vector);
        const confidence = calculateConfidence(similarity);
        const recommendation = confidence > 50 ? 'Yes' : 'No';

        return {
          ...item,
          confidence,
          recommendation,
        };
      }
    });

    setRecommendations(recs);
  }, [userResponses]);

  return (
    <div className="ballot-screen">
      <header>
        <h1>Your Ballot</h1>
        <p>Based on your civic blueprint</p>
      </header>

      <div className="ballot-items">
        {recommendations.map((item) => (
          <div key={item.id} className="ballot-item">
            <h2>{item.title}</h2>

            {item.type === 'candidate' ? (
              <>
                <div className="recommendation">
                  <strong>Recommended:</strong> {item.recommendation.name}
                </div>
                <ConfidenceGauge
                  confidence={item.recommendation.confidence}
                  label="Match"
                />
                <div className="all-candidates">
                  {item.allCandidates.map((candidate: any) => (
                    <div key={candidate.name} className="candidate">
                      <div>{candidate.name} ({candidate.party})</div>
                      <div className="mini-confidence">{candidate.confidence}%</div>
                    </div>
                  ))}
                </div>
              </>
            ) : (
              <>
                <p className="description">{item.description}</p>
                <div className="recommendation">
                  <strong>Recommendation:</strong> Vote {item.recommendation}
                </div>
                <ConfidenceGauge confidence={item.confidence} />
                <div className="outcomes">
                  <div className="outcome">
                    <strong>If Yes:</strong> {item.outcomes.yes}
                  </div>
                  <div className="outcome">
                    <strong>If No:</strong> {item.outcomes.no}
                  </div>
                </div>
                <p className="explanation">{item.explanation}</p>
              </>
            )}
          </div>
        ))}
      </div>
    </div>
  );
};
```

---

## Quick Setup Instructions

### 1. Create React App

```bash
npx create-react-app ballot-builder-prototype --template typescript
cd ballot-builder-prototype
```

### 2. Add the Files

Copy the components and data files from above into the appropriate directories.

### 3. Run It

```bash
npm start
```

Your prototype will open at `http://localhost:3000`!

---

## What This Prototype Demonstrates

âœ… **Core Concept:** Swipe â†’ Learn preferences â†’ Show recommendations
âœ… **Matching Algorithm:** Simple vector similarity calculation
âœ… **User Experience:** How the flow feels
âœ… **Visual Design:** What the UI could look like
âœ… **Confidence Scores:** How recommendations are presented

## What's Fake/Simplified

âŒ No real AI (vectors are hardcoded)
âŒ No backend or database
âŒ Limited data (5 statements, 3 ballot items)
âŒ No address lookup
âŒ No adaptive questions
âŒ No chatbot

---

## Extending the Prototype

### Easy Additions:
1. **More statements** - Add 20-30 more to statements.json
2. **Better styling** - Use Tailwind CSS or Material-UI
3. **Routing** - Add React Router for multi-page navigation
4. **Local storage** - Save progress so users can come back
5. **Share results** - Generate shareable link with results

### Medium Additions:
1. **Real AI** - Connect to OpenAI API for statement generation
2. **Real data** - Add actual ballot info for your district
3. **Visualization** - Add political compass chart
4. **Export PDF** - Generate printable ballot guide

### Advanced Additions:
1. **Backend** - Add Express server with database
2. **Authentication** - Let users save their profile
3. **Multiple elections** - Support different elections/locations

---

## Success Metrics

Your prototype is successful if:

âœ… You can demo the complete flow in 2-3 minutes
âœ… Testers understand what it does without explanation
âœ… The matching algorithm produces reasonable results
âœ… You've learned the core concepts
âœ… You can explain how it would scale to a real app

---

## Timeline Estimate

**Week 1:** Setup + Mock data + Basic components
**Week 2:** Swipe screen + Scoring logic
**Week 3:** Ballot screen + Polish + Testing

**Total:** 3 weeks for a working prototype

---

## Next Steps After Prototype

1. **Get feedback** from 5-10 people
2. **Identify what works** and what's confusing
3. **Decide** if you want to build the real thing
4. **Plan** which features to add next
5. **Consider** keeping it simple vs. full app

---

## Remember

> "A prototype is worth a thousand meetings"

The goal isn't to build the perfect app. It's to:
- **Learn** by doing
- **Validate** the concept
- **Communicate** the vision
- **Make decisions** based on real experience

Start simple, iterate quickly, get feedback early!

---

*Good luck with your prototype! ğŸš€*
